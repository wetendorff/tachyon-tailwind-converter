import '../js/modernizr-custom.js';

import bootstrapped from './bootstrapped';
import {
    AvailableRelationTypeEnum,
    ConsultationTypeEnum,
    PartnerStatusEnum,
    ShouldPayConsultationTypeEnum,
} from './enums';
import { fetch } from './fetch';
import {
    IShouldPay,
    IUpdateSelfRequest,
    ISelfResponse,
    IStatus,
} from './interfaces';
import { Log } from './Log';
import { Texts } from './Texts';
import { VidyoLoader } from './VidyoLoader';
import moment from 'moment';
import { format, parseISO } from 'date-fns';
import { da, enGB } from 'date-fns/locale';

declare let Modernizr: any;
declare let safari: any;

export class Utils {
    public static pullingVideoCallInterval = 5000;

    public static getCachedCprKey = 'cachedCprKey';

    public static getParameterByName(name: string, url?: string): string {
        if (!url) {
            url = window.location.href;
        }
        name = name.replace(/[\[\]]/g, '\\$&');
        const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        const results = regex.exec(url);
        if (!results) {
            return null;
        }
        if (!results[2]) {
            return '';
        }
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    public static logout(): void {
        sessionStorage.clear();
        localStorage.clear();
        document.location.href = '/authentication/logoff';
    }

    public static getFullUrlAddress(url: string): string {
        return (
            window.location.protocol + '//' + window.location.host + '/' + url
        );
    }

    public static formatDateCalendar = (date: string): string => {
        return format(parseISO(date), Texts.get('dateFnsShortDateFormat'));
    };

    public static formatDateTime = (date: string): string => {
        return format(parseISO(date), Texts.get('dateFnsTimeFormat'));
    };

    public static formatRelativeDateTime(date: string): string {
        return moment(date).calendar();
    }

    public static returnEnumText = (n: number): string => {
        return ConsultationTypeEnum[n];
    };

    public static getCookie = (name: string): string => {
        const value = '; ' + document.cookie;
        const parts = value.split('; ' + name + '=');
        return parts[1]?.split(';').shift();
    };

    public static formatPrice(amount: number): string {
        if (amount === null) {
            return '';
        }
        const hasSubunits = amount % 1 !== 0;
        const n = hasSubunits ? 2 : 0; // decimals
        const x = 3; // whole part length
        const s = '.'; // section delimiter
        const c = ','; // decimal delimiter

        const re = '\\d(?=(\\d{' + x + '})+' + (n > 0 ? '\\D' : '$') + ')';
        const num = amount.toFixed(Math.max(0, ~~n));

        const price = num
            .replace('.', c)
            .replace(new RegExp(re, 'g'), '$&' + s);
        return hasSubunits ? price : price + ',-';
    }

    public static formatDisplayShortDateTime(date: string): string {
        if (!date) {
            return '';
        }
        const datePart = format(
            parseISO(date),
            Texts.get('dateFnsShortDateFormat'),
        );
        const timePart = format(parseISO(date), Texts.get('dateFnsTimeFormat'));
        return Texts.get('dateAndTime', {
            date: datePart,
            time: timePart,
        });
    }

    public static formatDisplayLongDateTime(date: string): string {
        if (!date) {
            return '';
        }

        const userLocale = navigator.language === 'da-DK' ? da : enGB;

        const datePart = format(
            parseISO(date),
            Texts.get('dateFnsLongDateFormat'),
            { locale: userLocale },
        );

        const timePart = format(
            parseISO(date),
            Texts.get('dateFnsTimeFormat'),
            { locale: userLocale },
        );

        return Texts.get('dateAndTime', {
            date: datePart,
            time: timePart,
        });
    }

    public static formatDateAndTime(date: string): string {
        if (!date) {
            return '';
        }
        return format(parseISO(date), Texts.get('dateFnsShortDateFormat'));
    }

    public static formatDateTimeAsCalendar(
        date: string,
        capitalize: boolean,
    ): string {
        if (!date) {
            return '';
        }

        // parse incoming date
        const parsedDate = moment(date, Texts.get('momentShortDateTimeFormat'));

        // format date?
        const formattedDate = parsedDate.calendar();

        if (capitalize) {
            return this.capitalize(formattedDate);
        }

        return formattedDate;
    }

    private static capitalize(str: string): string {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    public static relationTypeText(
        relationType: AvailableRelationTypeEnum,
    ): string {
        switch (relationType) {
            case AvailableRelationTypeEnum.Child:
                return Texts.getResource('Child');
            case AvailableRelationTypeEnum.Partner:
                return Texts.getResource('Partner');
            default:
                return '';
        }
    }

    public static getApiUrl(url: string): string {
        return (
            window.location.protocol + '//' + window.location.host + '/' + url // IM A COMMENT
        );
    }

    public static fetch<T>(
        url: string,
        method = 'GET',
        data?: any,
        contentType?: string,
    ): Promise<T> {
        return fetch(url, method, data, contentType);
    }

    public static ajaxCall(
        requestType: string,
        url: string,
        successCallBack: (
            data: any,
            textStatus: string,
            jqXhr: JQueryXHR,
        ) => any,
        errorCallBack?: (
            jqXhr: JQueryXHR,
            textStatus: string,
            error: string,
        ) => any,
        data?: any,
        contentType?: string,
        isAsync?: boolean,
    ) {
        const settings: JQueryAjaxSettings = {
            async: isAsync ? isAsync : true,
            contentType: contentType ? contentType : 'application/json',
            data,
            error: (request: JQueryXHR, status: string, error: string) => {
                if (request.status === 401) {
                    this.logout();
                    return;
                }

                if (errorCallBack) {
                    errorCallBack(request, status, error);
                    return;
                }

                Log.error(
                    `API call failed and no error callback provided. url=${url} status=${request.status} response=${request.responseJSON}`,
                );
            },
            success: successCallBack,
            url: this.getApiUrl(url),
            type: requestType,
            headers: {
                'Accept-Language': 'da',
            },
        };

        $.ajax(settings);
    }

    public static getPartnerStatus = (status: PartnerStatusEnum): string => {
        switch (status) {
            case PartnerStatusEnum.NoPartner:
                return Texts.getResource('NoPartner');
            case PartnerStatusEnum.Invited:
                return Texts.getResource('Invited');
            case PartnerStatusEnum.Active:
                return Texts.getResource('Active');
            default:
                return '';
        }
    };

    public static shouldPayConsultation(
        consultationType: ShouldPayConsultationTypeEnum,
    ): boolean {
        return Utils.getShouldPayResponse(
            bootstrapped.ShouldPay,
            consultationType,
        );
    }

    public static updateCpr(cpr: string): JQueryDeferred<boolean> {
        const p = $.Deferred<boolean>();

        const request: IUpdateSelfRequest = {
            Name: null,
            Email: null,
            CPR: cpr,
            Mobile: null,
        };

        const callBackAjax = (
            data: IStatus<ISelfResponse>,
            status: string,
            jqXhr: JQueryXHR,
        ): void => {
            if (data.HasErrors) {
                p.reject(data.Errors.map((e) => e.Value).join());
            } else {
                p.resolve();
            }
        };

        const errorCallBack = (
            jqXhr: JQueryXHR,
            textStatus: string,
            error: string,
        ): void => {
            p.reject(error);
        };

        Utils.ajaxCall(
            'POST',
            'api/patients/self/v2',
            callBackAjax,
            errorCallBack,
            JSON.stringify(request),
        );

        return p;
    }

    public static shouldPay(
        consultationType: ShouldPayConsultationTypeEnum,
    ): JQueryDeferred<boolean> {
        const p = $.Deferred<boolean>();

        const successCallBack = (response: IShouldPay) => {
            p.resolve(Utils.getShouldPayResponse(response, consultationType));
        };

        const errorCallBack = (request: any, status: any, error: any) => {
            p.reject(error);
        };

        Utils.ajaxCall(
            'GET',
            'api/patients/shouldpay',
            successCallBack,
            errorCallBack,
            null,
            null,
            false,
        );

        return p;
    }

    public static shouldPayConsultationWithGracePeriodCheck(
        consultationUid: string,
        consultationType: ShouldPayConsultationTypeEnum,
    ): JQueryDeferred<boolean> {
        const p = $.Deferred<boolean>();

        const successCallBack = (response: IShouldPay) => {
            p.resolve(Utils.getShouldPayResponse(response, consultationType));
        };

        const errorCallBack = (request: any, status: any, error: any) => {
            p.reject(error);
        };

        Utils.ajaxCall(
            'GET',
            'api/patients/shouldpay/v2/' + consultationUid,
            successCallBack,
            errorCallBack,
            null,
            null,
            false,
        );

        return p;
    }

    public static CacheName(newName: string): void {
        Utils.cache(Utils.getCachedNameKey, newName);
    }

    public static GetCachedName(): string {
        return Utils.getCached(Utils.getCachedNameKey);
    }

    public static CachePhone(newPhone: string): void {
        Utils.cache(Utils.getCachedPhoneKey, newPhone);
    }

    public static GetCachedPhone(): string {
        return Utils.getCached(Utils.getCachedPhoneKey);
    }

    public static CacheCpr(newCpr: string): void {
        Utils.cache(Utils.getCachedCprKey, newCpr);
    }

    public static GetCachedCPR(): string {
        return Utils.getCached(Utils.getCachedCprKey);
    }

    public static getShouldPayResponse(
        response: IShouldPay,
        consultationType: ShouldPayConsultationTypeEnum,
    ): boolean {
        switch (consultationType) {
            case ShouldPayConsultationTypeEnum.Doctor:
                return response.ShouldPayDoctorConsultation;
            case ShouldPayConsultationTypeEnum.Midwife:
                return response.ShouldPayMidwifeConsultation;
            case ShouldPayConsultationTypeEnum.Dentist:
                return response.ShouldPayDentistConsultation;
            case ShouldPayConsultationTypeEnum.Dermatologist:
                return response.ShouldPayDermatologistConsultation;
            case ShouldPayConsultationTypeEnum.Nurse:
                return response.ShouldPayNurseConsultation;
            case ShouldPayConsultationTypeEnum.Physiotherapist:
                return response.ShouldPayPhysiotherapistConsultation;
            case ShouldPayConsultationTypeEnum.Rheumatologist:
                return response.ShouldPayRheumtatoligstConsultation;
            case ShouldPayConsultationTypeEnum.Psychologist:
                return response.ShouldPayPsychologistConsultation;
            case ShouldPayConsultationTypeEnum.AllergyDoctor:
                return response.ShouldPayAllergyDoctorConsultation;
            case ShouldPayConsultationTypeEnum.SundVaegtDoctor:
                return response.ShouldPaySundVaegtStartupConsultation;
            case ShouldPayConsultationTypeEnum.SundVaegtNurse:
                return response.ShouldPaySundVaegtNurseCheckupMessage;
            case ShouldPayConsultationTypeEnum.SundVaegtNurseAdHocVideo:
                return response.ShouldPaySundVaegtNurseAdHocVideoConsultation;
            case ShouldPayConsultationTypeEnum.SundVaegtQuestionnaireMessage:
                return response.ShouldPaySundVaegtQuestionnaireMessageConsultation;
            case ShouldPayConsultationTypeEnum.PhysiotherapistQuestionnaireMessage:
                return response.ShouldPayPhysiotherapistQuestionnaireMessageConsultation;
            case ShouldPayConsultationTypeEnum.Dietitian:
                return response.ShouldPayDietitianVideoConsultation;
            default:
                throw new Error(
                    'Unknown ShouldPayConsultationTypeEnum value: ' +
                        consultationType,
                );
        }
    }

    public static isFreeUser(skipCache: boolean): JQueryDeferred<boolean> {
        const p = $.Deferred<boolean>();
        const subscriptionSessionStorage = sessionStorage.getItem('isb2b');
        const subscriptionSessionStorageSetDateWithOffset = parseInt(
            sessionStorage.getItem('isb2bDate'),
            10,
        );

        if (
            !skipCache &&
            subscriptionSessionStorageSetDateWithOffset !== null &&
            subscriptionSessionStorage !== null
        ) {
            const now = new Date(Date.now());
            const nowDate = new Date(
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate(),
                now.getUTCHours(),
                now.getUTCMinutes(),
                0,
                0,
            );
            const nowTicks = nowDate.getTime();

            if (subscriptionSessionStorageSetDateWithOffset > nowTicks) {
                p.resolve(subscriptionSessionStorage === 'true');
                return p;
            }
        }

        const successCallBack = (response: boolean) => {
            sessionStorage.setItem('isb2b', response ? 'true' : 'false');

            const stored = new Date(Date.now());
            const storedDateWithOffset = new Date(
                stored.getUTCFullYear(),
                stored.getUTCMonth(),
                stored.getUTCDate(),
                stored.getUTCHours(),
                stored.getUTCMinutes() + 10,
                0,
                0,
            );
            const storedTicksWithOffset = storedDateWithOffset.getTime();
            sessionStorage.setItem(
                'isb2bDate',
                storedTicksWithOffset.toString(),
            );

            p.resolve(response);
        };

        const errorCallBack = (request: any, status: any, error: any) => {
            sessionStorage.removeItem('isb2b');
            p.reject(error);
        };

        Utils.ajaxCall(
            'GET',
            'api/patients/free',
            successCallBack,
            errorCallBack,
            null,
            null,
            false,
        );
        return p;
    }

    public static setPriceCheckboxText(price: number): string {
        return (
            Texts.getResource('RequirePaymentText') +
            ' (' +
            Utils.formatPrice(price) +
            ')'
        );
    }

    public static addDkkCurrency(price: number): string {
        return price + ' dkk.';
    }

    /**
     * Calls a function repeatedely at the specified interval.
     *
     * @param millis: the time to wait in between executions
     * @param callback: the function to call
     *
     * @returns a handle function used to cancel/restart the execution
     */
    public static loop(millis: number, callback: any): () => any {
        let cancel = false;
        const loop = () => {
            if (!cancel) {
                window.setTimeout(() => {
                    if (!cancel) {
                        callback();
                        loop();
                    }
                }, millis);
            }
        };
        loop();
        return () => {
            cancel = true;
            return () => {
                return Utils.loop(millis, callback);
            };
        };
    }

    public static timeSpanStringToMinutes(timeSpan: string): number {
        const values = timeSpan.split(':');
        const hours = Number(values[0]);
        const minutes = Number(values[1]);
        return hours * 60 + minutes;
    }

    /**
     *  Does nothing
     */
    public static noop() {
        /**/
    }

    /* eslint-disable @typescript-eslint/ban-types */

    /**
     *  Creates a version of the function that can only be called one time.
     *  Repeated calls to the modified function will have no effect,
     *  returning the value from the original call.
     *
     *  NOTE: The result of the first call's set of arguments will be memomized
     *  and returned for all other calls regardless of the arguments passed to
     *  subsequent calls as the underlying function is never called again.
     */
    public static once(func: Function) {
        let ran = false;
        let memo: any;
        return (
            func &&
            function () {
                if (ran) {
                    return memo;
                }
                ran = true;
                memo = func.apply(this, arguments);
                func = null;
                return memo;
            }
        );
    }

    /**
     * Partially applies a function
     * @param func the function
     * @param pArgs the partial aguments
     */
    public static pApply(func: Function, ...pArgs: any[]) {
        return (...args: any[]) => func(...[...pArgs, ...args]);
    }

    public static loopAsync(
        millis: number,
        func: Function,
        callback: Function,
    ) {
        let cancel = false;
        const loop = () => {
            if (!cancel) {
                window.setTimeout(() => {
                    if (!cancel) {
                        func((...args: any[]) => {
                            if (!cancel) {
                                callback(...args);
                                loop();
                            }
                        });
                    }
                }, millis);
            }
        };
        loop();
        return () => {
            cancel = true;
            return () => {
                Utils.loopAsync(millis, func, callback);
            };
        };
    }

    /* eslint-enable @typescript-eslint/ban-types */

    public static loadVidyoClientLibrary(callback: string): void {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        VidyoLoader.load(window[callback]);
    }

    public static isWebRtcBrowser(): boolean {
        return (
            Modernizr.getusermedia &&
            (Modernizr.datachannel || Modernizr.peerconnection)
        );
    }

    public static isMobileOrTablet(): boolean {
        let check = false;
        ((a) => {
            if (
                /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
                    a,
                ) ||
                /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                    a.substr(0, 4),
                )
            ) {
                check = true;
            }
        })(navigator.userAgent || navigator.vendor || (window as any).opera);
        return check;
    }

    public static isIos(): boolean {
        return navigator.userAgent.match(/iPhone|iPad/i) !== null;
    }

    public static isVideoDevice(): boolean {
        return Utils.isWebRtcBrowser() && !Utils.isIos() && !Utils.isOldEdge();
    }

    // returns true if unsupported
    public static redirectIfUnsupported(): boolean {
        // prevent redirect loops
        if (/^\/unsupported/i.test(document.location.pathname)) {
            return false;
        }

        if (this.isVideoDevice()) {
            return false;
        }

        if (this.isAndroid()) {
            document.location.href = '/unsupported/android';
            return true;
        }

        if (this.isIos()) {
            document.location.href = '/unsupported/ios';
            return true;
        }

        document.location.href = '/unsupported/desktop';
        return true;
    }

    private static getCachedNameKey = 'cachedNameKey';

    private static getCachedPhoneKey = 'cachedTelKey';

    private static cache(key: string, value: string): void {
        if (!value) {
            return Utils.clearCache(key);
        }
        sessionStorage.setItem(key, value);
    }

    private static getCached(key: string): string {
        return sessionStorage.getItem(key);
    }

    private static clearCache(key: string): void {
        sessionStorage.removeItem(key);
    }

    private static isAndroid(): boolean {
        return /android/i.test(navigator.userAgent);
    }

    private static isOldEdge(): boolean {
        return /edge\//i.test(navigator.userAgent);
    }

    private static isInternetExplorer(): boolean {
        return /*@cc_on!@*/ false || !!(document as any).documentMode;
    }

    public static formatCpr(cpr: string) {
        if (cpr) {
            return cpr.slice(0, -4) + '-' + cpr.slice(-4);
        }
        return cpr;
    }
}
